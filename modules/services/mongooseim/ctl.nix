{ pkgs, lib, config, ... }:

with lib;
with import ./erlexpr.nix;

let
  cfg = config.headcounter.programs.mongooseimctl;
  inherit (config.headcounter.services.mongooseim) package;

  ctlArgsFile = pkgs.writeText "ctl.args" ''
    -setcookie ${shErlEsc erlAtom cfg.cookie}
    -noinput
    -hidden
    -pa ${shErlEsc id "${package.mainAppDir}/ebin"}
    -s ejabberd_ctl
  '';

  mongooseimctl = pkgs.writeScriptBin "mongooseimctl" ''
    #!${pkgs.stdenv.shell}
    exec ${pkgs.erlang}/bin/erl \
      -args_file "${ctlArgsFile}" \
      -sname "ctl$$@${cfg.ctlHost}" \
      -extra "${cfg.destNodeName}" "$@"
  '';

in {
  options.headcounter.programs.mongooseimctl = {
    enable = mkEnableOption "MongooseIM controller";

    ctlHost = mkOption {
      default = config.networking.hostName;
      type = types.str;
      description = ''
        The host part of the node name to use for spawning the client side of
        the controller. A random node name will be generated at runtime.
      '';
    };

    destNodeName = mkOption {
      default = "mongooseim@${config.networking.hostName}";
      type = types.str;
      description = ''
        Erlang node name of the MongooseIM server to control.
      '';
    };

    cookie = mkOption {
      example = "super_secret_random_sequence";
      type = types.str;
      description = ''
        The magic cookie used for communicating with the MongooseIM Erlang node.
      '';
    };

    ctlTool = mkOption {
      type = types.path;
      internal = true;
      description = ''
        The full path to the <literal>mongooseimctl</literal> tool, generated by
        this very module.
      '';
    };
  };

  config = mkIf cfg.enable {
    environment.systemPackages = singleton mongooseimctl;
    headcounter.programs.mongooseimctl = {
      ctlTool = "${mongooseimctl}/bin/mongooseimctl";
    };
  };
}
